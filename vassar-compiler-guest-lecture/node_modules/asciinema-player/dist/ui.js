import { c as coreOpts, m as mount, u as uiOpts } from './opts-431a15ad.js';
import { D as DummyLogger } from './logging-0e62dee8.js';

function create(src, elem, workerUrl) {
  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const coreLogger = opts.logger === console ? true : undefined;
  const core = new CoreWorkerProxy(workerUrl, src, coreOpts(opts, {
    logger: coreLogger
  }));
  const uiLogger = opts.logger ?? new DummyLogger();
  return mount(core, elem, uiOpts(opts, {
    logger: uiLogger
  }));
}
class CoreWorkerProxy {
  constructor(workerUrl, src, opts) {
    this.worker = new Worker(workerUrl);
    this.worker.onmessage = this._onMessage.bind(this);
    this.src = src;
    this.opts = opts;
    this.nextId = 1;
    this.eventHandlers = new Map([["ended", []], ["errored", []], ["idle", []], ["init", []], ["input", []], ["loading", []], ["marker", []], ["offline", []], ["pause", []], ["play", []], ["playing", []], ["reset", []], ["resize", []], ["seeked", []], ["terminalUpdate", []]]);
    this.resolves = new Map();
    this._sendCommand("new", [this.src, this.opts]);
  }
  async init() {
    return this._sendCommand("init");
  }
  play() {
    return this._sendCommand('play');
  }
  pause() {
    return this._sendCommand('pause');
  }
  togglePlay() {
    return this._sendCommand('togglePlay');
  }
  seek(where) {
    return this._sendCommand('seek', where);
  }
  step(n) {
    return this._sendCommand('step', n);
  }
  stop() {
    return this._sendCommand('stop');
  }
  getChanges() {
    return this._sendCommand('getChanges');
  }
  getCurrentTime() {
    return this._sendCommand('getCurrentTime');
  }
  getRemainingTime() {
    return this._sendCommand('getRemainingTime');
  }
  getProgress() {
    return this._sendCommand('getProgress');
  }
  getDuration() {
    return this._sendCommand('getDuration');
  }
  addEventListener(eventName, handler) {
    const handlers = this.eventHandlers.get(eventName);
    if (handlers.length === 0) {
      this._sendNotification("addEventListener", [eventName]);
    }
    handlers.push(handler);
  }
  _dispatchEvent(eventName) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    for (const h of this.eventHandlers.get(eventName)) {
      h(data);
    }
  }
  _sendCommand(name, args) {
    let resolve_;
    const promise = new Promise(resolve => {
      resolve_ = resolve;
    });
    this.resolves.set(this.nextId, resolve_);
    this.worker.postMessage({
      method: name,
      params: args,
      id: this.nextId
    });
    this.nextId++;
    return promise;
  }
  _sendNotification(name, args) {
    this.worker.postMessage({
      method: name,
      params: args
    });
  }
  _onMessage(e) {
    if (e.data.id !== undefined) {
      this.resolves.get(e.data.id)(e.data.result);
      this.resolves.delete(e.data.id);
    } else if (e.data.method === "onEvent") {
      this._dispatchEvent(e.data.params.name, e.data.params.event);
    }
  }
}

export { create };
